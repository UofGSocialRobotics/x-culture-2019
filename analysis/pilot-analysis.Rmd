---
title: "XC Analysis 2019 (fixed questions)"
author: "csaund"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(pwr)
library(ordinal)
library(gridExtra)
library(RColorBrewer)
```


### Naming scheme
wg1.0.e == "western gesture 1, condition 0, eastern viewer culture"
eg4.2.w == "eastern gesture 4 condition 2, western viewer culture"

# Part One: Overlapping Metaphors!?!?

## Load 'N' Wrangle

Load these bad larrys (straight from mTurk template)
```{r}
xcdata <- rbind(read.csv('xc_pilot_fixed_questions.csv'), read.csv('xc_pilot_fixed_questions2.csv')) %>%
  select(Answer.accessible, Answer.confident, Answer.conflict, Answer.control, 
         Answer.dominant, Answer.goal, Answer.many, Answer.members, 
         Answer.open, Answer.sure, Answer.tension, Answer.worktogether,
         Answer.vid_id)

wg1.0.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_1-0.mov") %>%
  select(-Answer.vid_id)

wg1.1.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_1-1.mov") %>%
  select(-Answer.vid_id)

wg1.2.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_1-2.mov") %>%
  select(-Answer.vid_id)

wg2.0.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_2-0.mov") %>%
  select(-Answer.vid_id)

wg2.1.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_2-1.mov") %>%
  select(-Answer.vid_id)

wg2.2.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_2-2.mov") %>%
  select(-Answer.vid_id)

wg3.0.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_3-0.mov") %>%
  select(-Answer.vid_id)

wg3.1.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_3-1.mov") %>%
  select(-Answer.vid_id)

wg3.2.w <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_3-2.mov") %>%
  select(-Answer.vid_id)
```


Also load these buggerinos (from psytoolkit template)
```{r}
psydata <- rbind(read.csv('psytoolkit_pilot.csv'), read.csv('psytoolkit_pilot2.csv')) %>% 
  na.omit() %>%
  distinct()
colnames(psydata) <- c("participantID", "vid_id", "rand", "free_response", 
                 "Answer.many", "Answer.members", "Answer.conflict", "Answer.tension",
                 "Answer.open", "Answer.accessible", "Answer.control", "Answer.dominant",
                 "Answer.worktogether", "Answer.goal", "Answer.sure", "Answer.confident",
                 "endcode", "t_start", "t_end", "t_total") 

wg4.0.w <- psydata %>%
  filter(vid_id == 
           "334666350") %>%
  select(-vid_id, -rand, -participantID, -t_start, -t_end, -t_total, -endcode, -free_response)

wg4.1.w <- psydata %>%
  filter(vid_id == 
           "334666369") %>%
  select(-vid_id, -rand, -participantID, -t_start, -t_end, -t_total, -endcode, -free_response)

wg4.2.w <- psydata %>%
  filter(vid_id == 
           "334666395") %>%
  select(-vid_id, -rand, -participantID, -t_start, -t_end, -t_total, -endcode, -free_response)

wg5.0.w <- psydata %>%
  filter(vid_id == 
           "334666150") %>%
  select(-vid_id, -rand, -participantID, -t_start, -t_end, -t_total, -endcode, -free_response)

wg5.1.w <- psydata %>%
  filter(vid_id == 
           "334666125") %>%
  select(-vid_id, -rand, -participantID, -t_start, -t_end, -t_total, -endcode, -free_response)

wg5.2.w <- psydata %>%
  filter(vid_id == 
           "334666100") %>%
  select(-vid_id, -rand, -participantID, -t_start, -t_end, -t_total, -endcode, -free_response)
```

### Spot checks 
some things should correlate, others should not. IE the questions that go together should correlate. 
accessible <--> open
confident <--> sure
conflict <--> tension
dominant <--> control
goal <--> worktogether
many <--> members

So now we group the metaphor measures by group and facet wrap by that. EZ

```{r}
add_groups <- function(data) {
  data$group <- ""
  for(row in 1:nrow(data)) {
    if (data$metaphor_measure[row] == "Answer.accessible") {
               data$group[row] <- "openness"
    } else if (data$metaphor_measure[row] == "Answer.open") {
              data$group[row] <- "openness"
    } else if (data$metaphor_measure[row] == "Answer.confident") {
              data$group[row] <- "certainty"
    } else if (data$metaphor_measure[row] == "Answer.sure") {
              data$group[row] <- "certainty"
    } else if (data$metaphor_measure[row] == "Answer.conflict") {
              data$group[row] <- "conflict"
    } else if (data$metaphor_measure[row] == "Answer.tension") {
              data$group[row] <- "conflict"
    } else if (data$metaphor_measure[row] == "Answer.control") {
               data$group[row] <- "control"
    } else if (data$metaphor_measure[row] == "Answer.dominant") {
              data$group[row] <- "control"
    } else if (data$metaphor_measure[row] == "Answer.goal") {
              data$group[row] <- "unity"
    } else if (data$metaphor_measure[row] == "Answer.worktogether") {
              data$group[row] <- "unity"
    } else if (data$metaphor_measure[row] == "Answer.many") {
              data$group[row] <- "size"
    } else if (data$metaphor_measure[row] == "Answer.members") {
              data$group[row] <- "size"              
    } else {
      # for some reason it's not recognizing the annoyed case, so let's throw it in the else
      # cause that seems safe.
      data$group[row] <- "other"
    }
  }
  return(data)
}
```


Create grouped overlay of correlated questions. Violin plot of question correlations by group (for single conditions of a single gesture)
```{r}
create_grouped_overlay <- function(data) {
  p <- ggplot(data) + 
    aes(x=factor(nrow(data)),y=score,fill=metaphor_measure)+
    geom_violin(alpha=0.3,position="identity") +
    facet_wrap("group")  
  return(p)    
}
```

This graph shows the correlation of the grouped variables. We want them to be highly correlated with each other, and preferably not super correlated with one another. This should hold moreso for the extreme versions of the gestures.


Really could have correlation plot w Q1 on X and Q2 on Y but those don't look great and we shouldn't expect them to... 

### Correlation Matrix of questions
Get wrapped plot of correlations across conditions for same gesture
```{r}
## Go through and populate with metaphors and difference values
create_difference_matrix <- function(data) {
  difference_table <- data.frame(
    Question1 = c(""),
    Question2 = c(""),
    Rsq = c(""),
    stringsAsFactors=FALSE
  )
  
  metas = colnames(data)
  
  for(metaphor in metas) {
    for(meta in rev(metas)) {
      diff <- cor(data[meta], data[metaphor])
      row <- c(metaphor, meta, diff)
      difference_table <- rbind(difference_table, row)  
    }
  }
  
  difference_table <- difference_table[-1,]
  difference_table$Rsq <- as.numeric(as.character(difference_table$Rsq))
  
  return(difference_table)
}
```

```{r}
plot_diff_matrix <- function(matrix, low_col, high_col, mid_col, title) {
  p <- ggplot(data=matrix, aes(x=Question1, y=Question2, fill=Rsq)) + 
    geom_tile(color="white") +
    scale_fill_gradient2(low=low_col, high=high_col, mid=mid_col,
                         midpoint=0.25, space="Lab") +
    theme_minimal() +
    coord_fixed() +
    theme_bw() +
    theme(axis.text.x=element_text(angle=90),
        axis.ticks=element_blank(),
        axis.line=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_line(color='#eeeeee')) +
      ggtitle(title)
  return(p)
}

plot_diff_matrix_pretty <- function(matrix, t="") {
  plot_diff_matrix(matrix, "palevioletred", "royalblue4", "aliceblue", title=t)
}
```


### Violin plots of responses to questions
```{r}
plot_violin_density <- function(d0, d1, d2) {
  g <- ggplot(rbind(d0, d1, d2), aes(vid, score)) + 
    geom_violin(aes(fill=vid, alpha=0.5), scale="count", draw_quantiles = c(0.25, 0.5, 0.75)) +
    facet_wrap(~metaphor_measure) + 
    labs(
      title = "Violin plot (density) of ranked responses per condition by metaphor",
      caption = "Horizontal lines are drawn at the 0.25, 0.5, and 0.75 quantiles of the distribution."
    )
  return(g)
}

plot_violin_density_grouped <- function(d0, d1, d2) {
  g <- ggplot(rbind(d0, d1, d2), aes(vid, score)) + 
    geom_violin(aes(fill=vid, alpha=0.5), scale="count", draw_quantiles = c(0.25, 0.5, 0.75)) +
    facet_wrap(~group) + 
    labs(
      title = "Violin plot (density) of ranked responses per condition by metaphor"   ,
      caption = "Horizontal lines are drawn at the 0.25, 0.5, and 0.75 quantiles of the distribution."
    )
  return(g)
}

plot_violin_density_group_overlay <- function(d0, d1, d2) {
  g <- ggplot(rbind(d0, d1, d2)) + 
    aes(x=factor(nrow(d0)),y=score,fill=vid)+
    geom_violin(alpha=0.3,position="identity") +
    facet_wrap("group") +
    labs(
      title = "Violin plot (density) of ranked responses per condition by metaphor grouping"
    )
  return(g)
}
```


### Density plot? 
Regrouping data in a potentially horrifying way. Need to make sure questions make sense...

Group it all together and do it by group but you can also just do it by groups and facet wrap by metaphor measure for 
indiv question results. 
```{r}
plot_group_density <- function(d0, d1, d2) {
  p <- ggplot(rbind(d0, d1, d2), aes(x=score, fill=vid)) + 
      geom_density(alpha=0.3, stat="density", adjust=1.2) +
      facet_wrap(~group, scale="free")
  return(p)  
}

plot_question_density <- function(d0, d1, d2) {
  p <- ggplot(rbind(d0, d1, d2), aes(x=score, fill=vid)) + 
      geom_density(alpha=0.3, stat="density", adjust=1.2) +
      facet_wrap(~metaphor_measure, scale="free")
  return(p)  
}
```


#### Put it together and how do you do? Bibbity Bobbity BAM.
```{r}
## random helpers
gather_select <- function(d) {
  d <- d %>%
    gather("metaphor_measure", "score", 1:12) %>%
    select("metaphor_measure", "score")
}

wrangle_data <- function(d, name="data") {
  gathered <- gather_select(d)
  grouped <- add_groups(gathered)
  overlay_plot <- create_grouped_overlay(grouped)
  diff_mat <- create_difference_matrix(d)
  diff_mat$vid <- name
  list_of_returns <- list("gathered" = gathered, "grouped" = grouped, "overlay_plot" = overlay_plot, "diff_mat" = diff_mat)
  return(list_of_returns)
}

do_the_thing <- function(d0, d1, d2, n0 = "original", n1 = "a_condition1", n2 = "z_condition2", gesture = "single") {
  d0_data <- wrangle_data(d0, n0)
  d1_data <- wrangle_data(d1, n1)
  d2_data <- wrangle_data(d2, n2)
  
  graph_title <- paste("Correlation of questions for", gesture, "gesture across conditions.")
  
  overlays <- list("d0_overlay" = d0_data$overlay_plot, 
                   "d1_overlay" = d1_data$overlay_plot, 
                   "d2_overlay" = d2_data$overlay_plot)
  difference_matrix <- plot_diff_matrix_pretty(rbind(d0_data$diff_mat, d1_data$diff_mat, d2_data$diff_mat), 
                      graph_title) + 
                      facet_wrap("vid")  
  
  ## rename some things for the density plots
  db_named <- d0_data$gathered
  da_named <- d1_data$gathered
  dc_named <- d2_data$gathered
  db_named$vid = "original"
  da_named$vid = "a_condition1"
  dc_named$vid = "z_condition2"
  d0_grouped_named <- add_groups(da_named)
  d1_grouped_named <- add_groups(db_named)
  d2_grouped_named <- add_groups(dc_named)
  
  ## violin density plot 
 violin_density_question <- plot_violin_density(da_named, db_named, dc_named) 
 violin_density_grouped <- plot_violin_density_grouped(d0_grouped_named, d1_grouped_named, d2_grouped_named)
 violin_dnesity_grouped_overlay <- plot_violin_density_group_overlay(d0_grouped_named, d1_grouped_named, d2_grouped_named)
 
 ## plot density plot -- with groups
 density_grouped <- plot_group_density(d0_grouped_named, d1_grouped_named, d2_grouped_named)
 density_question <- plot_question_density(d0_grouped_named, d1_grouped_named, d2_grouped_named)
 
 return_list <- list("overlays" = overlays, 
                     "correlation_matrix" = difference_matrix, 
                     "violin_density_question" = violin_density_question, 
                     "violin_density_grouped" = violin_density_grouped,
                     "violin_density_grouped_overlay" = violin_dnesity_grouped_overlay,
                     "density_grouped" = density_grouped, 
                     "density_question" = density_question)
}

all_wg1_data <- do_the_thing(wg1.0.w, wg1.1.w, wg1.2.w, "original", "intertwine", "collide")
all_wg2_data <- do_the_thing(wg2.0.w, wg2.1.w, wg2.2.w)
all_wg3_data <- do_the_thing(wg3.0.w, wg3.1.w, wg3.2.w)
all_wg4_data <- do_the_thing(wg4.0.w, wg4.1.w, wg4.2.w)
all_wg5_data <- do_the_thing(wg5.0.w, wg5.1.w, wg5.2.w)

all_western_correlational_data <- plot_diff_matrix_pretty(rbind(create_difference_matrix(wg1.0.w), 
                                                        create_difference_matrix(wg1.1.w), 
                                                        create_difference_matrix(wg1.2.w),
                                                        create_difference_matrix(wg2.0.w), 
                                                        create_difference_matrix(wg2.1.w), 
                                                        create_difference_matrix(wg2.2.w),
                                                        create_difference_matrix(wg4.0.w), 
                                                        create_difference_matrix(wg4.1.w), 
                                                        create_difference_matrix(wg4.2.w),
                                                        create_difference_matrix(wg5.0.w), 
                                                        create_difference_matrix(wg5.1.w),
                                                        create_difference_matrix(wg5.2.w),
                                                        create_difference_matrix(wg3.0.w), 
                                                        create_difference_matrix(wg3.1.w), 
                                                        create_difference_matrix(wg3.2.w)), 
    "Correlation of questions across all gesture conditions") 

## save some other things too why not
# ggsave(filename = "all_unpolite_data--violin_density_grouped.png", plot = all_wg1_data$violin_density_grouped_overlay)
# ggsave(filename = "all_entity_data--violin_density_grouped.png", plot = all_wg2_data$violin_density_grouped_overlay)
# ggsave(filename = "all_audience_data--violin_density_grouped.png", plot = all_wg3_data$violin_density_grouped_overlay)
# ggsave(filename = "all_protected_data--violin_density_grouped.png", plot = all_wg4_data$violin_density_grouped_overlay)
# ggsave(filename = "all_bowl_data--violin_density_grouped.png", plot = all_wg5_data$violin_density_grouped_overlay)
# 
# ggsave(filename = "all_western_correlational_data.png", plot = all_western_correlational_data)
```

Cool now access everything as follows:
all_dat$overlays[["d0_overlay"]]: the overlayed violin plot of related questions. Illustrates density overlay aka a nice vis of correlation of questions
all_dat$correlation_matrix: the correlation matrices that visualize the above as well.
all_dat$violin_density_question: the violin plot of all question distributions across gesture conditions.
all_dat$violin_density_grouped: the violin plot of group distributions across gesture conditions.
all_dat$density_grouped: density plot of group distributions across gesture conditions.
all_dat$density_question: density plot of all question distributions across gesture conditions.

if you want to plot all of the overlays nicely you can do this:
```{r}
#p1 <- all_wg1_data$overlays[["d0_overlay"]]
#p2 <- all_wg2_data$overlays[["d1_overlay"]]
#p3 <- all_wg3_data$overlays[["d2_overlay"]]
#grid.arrange(p1, p2, p3, ncol=3)
```


## Stats
Pretty, but what does it mean? Well, to determine whether any of these differences are significant (aka, did people interpret different things from each of the different gesture conditions, which, because we, too, are people, we know they did) we need to see what the significant differences between rankings in each gesture and condition are.
```{r}
## gather the bad larries
gather_clean <- function(d, n="") {
  ret <- d %>%
    gather("metaphor_measure", "score", 1:12) %>%
    mutate(condition=n) %>%
    add_groups()
  return(ret)
}

do_anova_per_group <- function(data, g) {
  group_data <- data %>%
    filter(group==g)
  res.aov <- aov(score ~ condition, data=group_data)
  print(g)
  print(summary(res.aov))
  return(res.aov)
}

do_anova_per_data <- function(data) {
  groups <- c("openness",
              "conflict",
              "control", 
              "size",
              "certainty",
              "unity")
  
  print("==== BY GROUP ====")
  for (g in groups) {
    print(g)
    a <- do_anova_per_group(data, g)
    print(summary(a))
    print("========================")
  }
}

do_anova_per_gest <- function(d0, d1, d2) {
  d <- rbind(gather_clean(d0, "original"), 
             gather_clean(d1, "cond1"), 
             gather_clean(d2, "cond2"))
  do_anova_per_data(d)
}

do_all_anovas <- function() {
  print("!!!!UNPOLITE!!!!!")
  do_anova_per_gest(wg1.0.w, wg1.1.w, wg1.2.w)
  print(" ")
  print("!!!!ENTITY!!!!!")
  do_anova_per_gest(wg2.0.w, wg2.1.w, wg2.2.w)
  print(" ")
  print("!!!!AUDIENCE!!!!!")
  do_anova_per_gest(wg3.0.w, wg3.1.w, wg3.2.w)
  print(" ")
  print("!!!!PROTECTED!!!!!")
  do_anova_per_gest(wg4.0.w, wg4.1.w, wg4.2.w)
  print(" ")
  print("!!!!BOWL!!!!!")
  do_anova_per_gest(wg5.0.w, wg5.1.w, wg5.2.w)
}

do_all_anovas()
```


Now get those T-Tests done DID.

```{r}
get_sig_val <- function(p) {
  if(p < 0.0005) {
    return("***")
  }
  if(p < 0.005) {
    return("**")
    }
  if(p < 0.1) {
    return("*")
  }
  return ("")
}

get_nice_things <- function(d0, d1, d2, n0="original", n1="cond1", n2="cond2") {
  d0_g_cl <- gather_clean(d0, n0) 
  d1_g_cl <- gather_clean(d1, n1) 
  d2_g_cl <- gather_clean(d2, n2)
  d_total <- rbind(d0_g_cl, d1_g_cl, d2_g_cl)
  return(d_total)
}


## Have to do this hacky bit for getting the data frame and I haven't figured out why but 
## passing the data directly just doesn't play.
do_t_test_adjusted <- function(cond1, cond2, statement, dat) {
  d <- data.frame()
  if(dat == "1") {
    d <- get_nice_things(wg1.0.w, wg1.1.w, wg1.2.w)
  }
  if(dat == "2") {
    d <- get_nice_things(wg2.0.w, wg2.1.w, wg2.2.w)
  }
  if(dat == "3") {
    d <- get_nice_things(wg3.0.w, wg3.1.w, wg3.2.w)
  }
  if(dat == "4") {
    d <- get_nice_things(wg4.0.w, wg4.1.w, wg4.2.w)
    }
  if(dat == "5") {
    d <- get_nice_things(wg5.0.w, wg5.1.w, wg5.2.w)
  }
  
  p <- as.numeric(t.test(
            get_vals(cond1, statement, d),
            get_vals(cond2, statement, d))[3])
  p_adjusted <- round(p.adjust(p, method="bonferroni", n=18), digits=5)
  return(p_adjusted)
}

get_vals <- function(condition_name, g, dat) {
  ret <- dat %>%
    filter(condition==condition_name) %>%
    filter(group==g)
  ret <- ret$score  
  return(ret)
}


# For some reason can't generalize this to all gestures?
make_table_per_gesture <- function(gest_name, cond1name, cond2name, dat) {
  groups <- c("openness",
            "conflict",
            "control", 
            "size",
            "certainty",
            "unity")

  group <- rep(groups, each=3)
  cond1 <- rep(c(cond1name, cond2name, "original"), 6)
  cond2 <- rep(c("original", cond1name, cond2name), 6)
  df <- data.frame(group, cond1, cond2)   
  
  df$p <- mapply(do_t_test_adjusted, 
               as.character(df$cond1), 
               as.character(df$cond2), 
               as.character(df$group),
               dat)
  df$sig <- mapply(get_sig_val, df$p)

  return(df)
}


wg1_sig_table <- make_table_per_gesture("unpolite", "cond1", "cond2", "1")
wg2_sig_table <- make_table_per_gesture("entity", "cond1", "cond2", "2")
wg3_sig_table <- make_table_per_gesture("audience", "cond1", "cond2", "3")
wg4_sig_table <- make_table_per_gesture("protected", "cond1", "cond2", "4")
wg5_sig_table <- make_table_per_gesture("bowl", "cond1", "cond2", "5")
```




# PART TWO: BICULTURALISM AT ITS FINEST

## Wrangle these bad larries
```{r}
wrangle_mini <- function(d, cond="data", culture="western") {
  gathered <- gather_select(d)
  grouped <- add_groups(gathered)
  grouped$condition <- cond
  grouped$viewer_culture <- culture
  return(grouped)
}

create_total_bicultural_tables <- function(wd0, wd1, wd2, ed0, ed1, ed2, cond1="cond1", cond2="cond2") {
  d0_w <- wrangle_mini(wd0, "original", "western")
  d1_w <- wrangle_mini(wd1, cond1, "western")
  d2_w <- wrangle_mini(wd2, cond2, "western")
  d0_e <- wrangle_mini(ed0, "original", "eastern")
  d1_e <- wrangle_mini(ed1, cond1, "eastern")
  d2_e <- wrangle_mini(ed2, cond2, "eastern")
  
  total <- rbind(d0_w, d1_w, d2_w, d0_e, d1_e, d2_e) 
}

## Pretending that wg4 is our eastern viewers for wg1
## when we actually do it it'll be wg1.0.w, wg1.1.w, wg1.2.w, wg1.0.e, wg1.1.e, wg1.2.e
wg1_total <- create_total_bicultural_tables(wg1.0.w, wg1.1.w, wg1.2.w, wg4.0.w, wg4.1.w, wg4.2.w, "intertwine", "collide")

### could put this all in a loop but writing it out isn't so bad and it helps me see just how much data we have.
#Uncomment for a good time [[once we have the bi-cultural data]]
# wg2_total <- create_total_bicultural_tables(wg2.0.w, wg2.1.w, wg2.2.w, wg2.0.e, wg2.1.e, wg2.2.e, "cond1", "cond2")
# wg3_total <- create_total_bicultural_tables(wg3.0.w, wg3.1.w, wg3.2.w, wg3.0.e, wg3.1.e, wg3.2.e, "cond1", "cond2")
# wg4_total <- create_total_bicultural_tables(wg4.0.w, wg4.1.w, wg4.2.w, wg4.0.e, wg4.1.e, wg4.2.e, "cond1", "cond2")
# wg5_total <- create_total_bicultural_tables(wg5.0.w, wg5.1.w, wg5.2.w, wg5.0.e, wg5.1.e, wg5.2.e, "cond1", "cond2")

# eg1_total <- create_total_bicultural_tables(eg1.0.w, eg1.1.w, eg1.2.w, eg1.0.e, eg1.1.e, eg1.2.e, "cond1", "cond2")
# eg2_total <- create_total_bicultural_tables(eg2.0.w, eg2.1.w, eg2.2.w, eg2.0.e, eg2.1.e, eg2.2.e, "cond1", "cond2")
# eg3_total <- create_total_bicultural_tables(eg3.0.w, eg3.1.w, eg3.2.w, eg3.0.e, eg3.1.e, eg3.2.e, "cond1", "cond2")
# eg4_total <- create_total_bicultural_tables(eg4.0.w, eg4.1.w, eg4.2.w, eg4.0.e, eg4.1.e, eg4.2.e, "cond1", "cond2")
# eg5_total <- create_total_bicultural_tables(eg5.0.w, eg5.1.w, eg5.2.w, eg5.0.e, eg5.1.e, eg5.2.e, "cond1", "cond2")

```

cool now we have all that data in one place. We need to compare the western and eastern viewers across conditions. 

## Plot these bad larries.
Easy enough to do stats on means between cultures but baby I wanna see those VIOLIN PLOTSSSSSS.

Can only plot by one thing at a time (i.e. for a single gesture condition then visualize across 
metaphor measures, or for a single metaphor measure then visualize across conditions. The second doesn't make sense though....)
```{r}
violin_compare_cultures_across_meta_groups <- function(data, cond="original", gesture_name="unknown") {
  g <- ggplot(filter(data, condition == cond)) + 
    aes(x=factor(nrow(data)),y=score,fill=viewer_culture) +
    geom_violin(alpha=0.4,position="identity") +
    #scale_fill_brewer(palette="PiYG") +
    #scale_fill_manual(values=c("palevioletred1", "royalblue3")) +
    facet_wrap("group") +
    labs(
      title = paste("Comparison across cultures for", gesture_name, " -- ", cond, "Condition")
    ) 
  return(g)
}


get_violin_comparisons_per_gesture <- function(dat, cond1="cond1", cond2="cond2", gesture_name="unknown") {
  c0 <- violin_compare_cultures_across_meta_groups(dat, "original", gesture_name)
  c1 <- violin_compare_cultures_across_meta_groups(dat, cond1, gesture_name)
  c2 <- violin_compare_cultures_across_meta_groups(dat, cond2, gesture_name)
  return_list <- list("c0_violin_comparison"=c0, 
                      "c1_violin_comparison"=c1,
                      "c2_violin_comparison"=c2)
}

wg1_violin_culture_comparisons <- get_violin_comparisons_per_gesture(wg1_total, "intertwine", "collide", "wg1")

## Uncomment when there's more data
#wg2_violin_culture_comparisons <- get_violin_comparisons_per_gesture(wg2_total, "cond1", "cond2", "wg2")
#wg3_violin_culture_comparisons <- get_violin_comparisons_per_gesture(wg3_total, "cond1", "cond2", "wg3")
#wg4_violin_culture_comparisons <- get_violin_comparisons_per_gesture(wg4_total, "cond1", "cond2", "wg4")
#wg5_violin_culture_comparisons <- get_violin_comparisons_per_gesture(wg5_total, "cond1", "cond2", "wg5")

#eg1_violin_culture_comparisons <- get_violin_comparisons_per_gesture(eg1_total, "cond1", "cond2", "eg1")
#eg2_violin_culture_comparisons <- get_violin_comparisons_per_gesture(eg2_total, "cond1", "cond2", "eg2")
#eg3_violin_culture_comparisons <- get_violin_comparisons_per_gesture(eg3_total, "cond1", "cond2", "eg3")
#eg4_violin_culture_comparisons <- get_violin_comparisons_per_gesture(eg4_total, "cond1", "cond2", "eg4")
#eg5_violin_culture_comparisons <- get_violin_comparisons_per_gesture(eg5_total, "cond1", "cond2", "eg5")



```
Now the plots live in things like `wg1_violin_culture_comparisons$c0_violin_comparison`


Cool now across I actually don't think the other comparison makes sense because you're comparing things across different gestures which defeats the purpose of the visualizations. 

So anyway, 

### Stats
Could do ANOVAs but it doesn't necessarily make sense since we're just comparing two groups.
```{r}
bi_culture_t_test <- function(g1, g2) {
  p <- t.test(g1, g2)[3]$p.value
  p <- round(p.adjust(p, method="bonferroni", n=12), digits=5)
  return(p)
}

# data comes in as already filtered out by gesture/condition
make_table_per_gesturecondition_by_culture <- function(dat) {
  groups <- c("openness",
            "conflict",
            "control", 
            "size",
            "certainty",
            "unity")
  western_mean <- c()
  eastern_mean <- c()
  p <- c()
  sig <- c()
  ## it's not tricky or pretty but it's readable so get off my back, R coding purist h8rs
  for(g in groups) {
    w_only <- dat %>%
      filter(viewer_culture=="western", group==g)
    e_only <- dat %>%
      filter(viewer_culture=="eastern", group==g)
    
    western_mean <- append(western_mean, mean(w_only$score))
    eastern_mean <- append(eastern_mean, mean(e_only$score))
    p_v <- bi_culture_t_test(w_only$score, e_only$score)
    p <- append(p, p_v)
    sig <- append(sig,
                  get_sig_val(p_v))
  }

  df <- data.frame(groups, western_mean, eastern_mean, p, sig)   
  return(df)
} 


do_t_culture_groups <- function(dat, cond1="cond1", cond2="cond2", gesture_name="unknown") {
  c0 <- make_table_per_gesturecondition_by_culture(filter(dat, condition=="original"))
  c1 <- make_table_per_gesturecondition_by_culture(filter(dat, condition==cond1))
  c2 <- make_table_per_gesturecondition_by_culture(filter(dat, condition==cond2))
  
  return_list <- list("c0_comparison"=c0, 
                      "c1_comparison"=c1,
                      "c2_comparison"=c2)
}

wg1_total_cultural_comparison_tables <- do_t_culture_groups(wg1_total, "intertwine", "collide", "wg1")

## And again uncommnet here for fun times
# wg2_total_cultural_comparison_tables <- do_t_culture_groups(wg2_total, "cond1", "cond2", "wg2")
# wg3_total_cultural_comparison_tables <- do_t_culture_groups(wg3_total, "cond1", "cond2", "wg3")
# wg4_total_cultural_comparison_tables <- do_t_culture_groups(wg4_total, "cond1", "cond2", "wg4")
# wg5_total_cultural_comparison_tables <- do_t_culture_groups(wg5_total, "cond1", "cond2", "wg5")
# 
# eg1_total_cultural_comparison_tables <- do_t_culture_groups(eg1_total, "cond1", "cond2", "eg1")
# eg2_total_cultural_comparison_tables <- do_t_culture_groups(eg2_total, "cond1", "cond2", "eg2")
# eg3_total_cultural_comparison_tables <- do_t_culture_groups(eg3_total, "cond1", "cond2", "eg3")
# eg4_total_cultural_comparison_tables <- do_t_culture_groups(eg4_total, "cond1", "cond2", "eg4")
# eg5_total_cultural_comparison_tables <- do_t_culture_groups(eg5_total, "cond1", "cond2", "eg5")

```
Now all that data lives in things like `wg1_total_comparison_tables$c0_comparison`
that look like this:
WG1-0 (this name isn't here in the actual version, we just know from the naming scheme)
`r wg1_total_comparison_tables$c0_comparison`