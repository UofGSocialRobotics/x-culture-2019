---
title: "XC Analysis 2019 (fixed questions)"
author: "csaund"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(pwr)
library(ordinal)
```


## Load 'N' Wrangle

Load these bad larrys
```{r}
xcdata <- rbind(read.csv('xc_pilot_fixed_questions.csv'), read.csv('xc_pilot_fixed_questions2.csv')) %>%
  select(Answer.accessible, Answer.confident, Answer.conflict, Answer.control, 
         Answer.dominant, Answer.goal, Answer.many, Answer.members, 
         Answer.open, Answer.sure, Answer.tension, Answer.worktogether,
         Answer.vid_id)

u0 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_1-0.mov") %>%
  select(-Answer.vid_id)

u1 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_1-1.mov") %>%
  select(-Answer.vid_id)

u2 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_1-2.mov") %>%
  select(-Answer.vid_id)

e0 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_2-0.mov") %>%
  select(-Answer.vid_id)

e1 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_2-1.mov") %>%
  select(-Answer.vid_id)

e2 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_2-2.mov") %>%
  select(-Answer.vid_id)

a0 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_3-0.mov") %>%
  select(-Answer.vid_id)

a1 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_3-1.mov") %>%
  select(-Answer.vid_id)

a2 <- xcdata %>%
  filter(Answer.vid_id == 
           "https://s3.us-east-2.amazonaws.com/metaphoric-gestures-x-culture/western_gest_3-2.mov") %>%
  select(-Answer.vid_id)
```


### Spot checks 
some things should correlate, others should not. IE the questions that go together should correlate. 
accessible <--> open
confident <--> sure
conflict <--> tension
dominant <--> control
goal <--> worktogether
many <--> members

So now we group the metaphor measures by group and facet wrap by that. EZ

```{r}
add_groups <- function(data) {
  data$group <- ""
  for(row in 1:nrow(data)) {
    if (data$metaphor_measure[row] == "Answer.accessible") {
               data$group[row] <- "open"
    } else if (data$metaphor_measure[row] == "Answer.open") {
              data$group[row] <- "open"
    } else if (data$metaphor_measure[row] == "Answer.confident") {
              data$group[row] <- "sure"
    } else if (data$metaphor_measure[row] == "Answer.sure") {
              data$group[row] <- "sure"
    } else if (data$metaphor_measure[row] == "Answer.conflict") {
              data$group[row] <- "conflict"
    } else if (data$metaphor_measure[row] == "Answer.tension") {
              data$group[row] <- "conflict"
    } else if (data$metaphor_measure[row] == "Answer.control") {
               data$group[row] <- "control"
    } else if (data$metaphor_measure[row] == "Answer.dominant") {
              data$group[row] <- "control"
    } else if (data$metaphor_measure[row] == "Answer.goal") {
              data$group[row] <- "unity"
    } else if (data$metaphor_measure[row] == "Answer.worktogether") {
              data$group[row] <- "unity"
    } else if (data$metaphor_measure[row] == "Answer.many") {
              data$group[row] <- "size"
    } else if (data$metaphor_measure[row] == "Answer.members") {
              data$group[row] <- "size"              
    } else {
      # for some reason it's not recognizing the annoyed case, so let's throw it in the else
      # cause that seems safe.
      data$group[row] <- "other"
    }
  }
  return(data)
}
```



Create grouped overlay of correlated questions. Violin plot of question correlations by group (for single conditions of a single gesture)
```{r}
create_grouped_overlay <- function(data) {
  p <- ggplot(data) + 
    aes(x=factor(nrow(data)),y=score,fill=metaphor_measure)+
    geom_violin(alpha=0.3,position="identity") +
    facet_wrap("group")  
  return(p)    
}
```

This graph shows the correlation of the grouped variables. We want them to be highly correlated with each other, and preferably not super correlated with one another. This should hold moreso for the extreme versions of the gestures.


Really could have correlation plot w Q1 on X and Q2 on Y but frankly those don't look great and we shouldn't expect them to... 


### Correlation Matrix of questions
Get wrapped plot of correlations across conditions for same gesture
```{r}
## Go through and populate with metaphors and difference values
create_difference_matrix <- function(data) {
  difference_table <- data.frame(
    Question1 = c(""),
    Question2 = c(""),
    Rsq = c(""),
    stringsAsFactors=FALSE
  )
  
  metas = colnames(data)
  
  for(metaphor in metas) {
    for(meta in rev(metas)) {
      diff <- cor(data[meta], data[metaphor])
      row <- c(metaphor, meta, diff)
      difference_table <- rbind(difference_table, row)  
    }
  }
  
  # difference_matrix$Rsq <- as.numeric(as.character(difference_matrix$Rsq))
  difference_table <- difference_table[-1,]
  # there is some problem here with the difference numeric
  difference_table$Rsq <- as.numeric(as.character(difference_table$Rsq))
  #difference_table$difference <- scale_0_1(difference_table$difference)
  return(difference_table)
}
```

```{r}
plot_diff_matrix <- function(matrix, low_col, high_col, mid_col, title) {
  p <- ggplot(data=matrix, aes(x=Question1, y=Question2, fill=Rsq)) + 
    geom_tile(color="white") +
    scale_fill_gradient2(low=low_col, high=high_col, mid=mid_col,
                         midpoint=0.25, space="Lab") +
    theme_minimal() +
    coord_fixed() +
    theme_bw() +
    theme(axis.text.x=element_text(angle=90),
        axis.ticks=element_blank(),
        axis.line=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_line(color='#eeeeee')) +
      ggtitle(title)
  return(p)
}

plot_diff_matrix_pretty <- function(matrix, t="") {
  plot_diff_matrix(matrix, "palevioletred", "royalblue4", "aliceblue", title=t)
}
```


### Violin plots of responses to questions
```{r}
plot_violin_density <- function(d0, d1, d2) {
  g <- ggplot(rbind(d0, d1, d2), aes(vid, score)) + 
    geom_violin(aes(fill=vid, alpha=0.5), scale="count", draw_quantiles = c(0.25, 0.5, 0.75)) +
    #geom_dotplot(aes(color=condition), binaxis='y', stackdir='center', dotsize=0.5) +
    facet_wrap(~metaphor_measure) + 
    labs(
      title = "Violin plot (density) of ranked responses per condition by metaphor"   ,
      caption = "Horizontal lines are drawn at the 0.25, 0.5, and 0.75 quantiles of the distribution."
    )
  return(g)
}

plot_violin_density_grouped <- function(d0, d1, d2) {
  g <- ggplot(rbind(d0, d1, d2), aes(vid, score)) + 
    geom_violin(aes(fill=vid, alpha=0.5), scale="count", draw_quantiles = c(0.25, 0.5, 0.75)) +
    #geom_dotplot(aes(color=condition), binaxis='y', stackdir='center', dotsize=0.5) +
    facet_wrap(~group) + 
    labs(
      title = "Violin plot (density) of ranked responses per condition by metaphor"   ,
      caption = "Horizontal lines are drawn at the 0.25, 0.5, and 0.75 quantiles of the distribution."
    )
  return(g)
}
```


### Density plot? 
Regrouping data in a potentially horrifying way. Need to make sure questions make sense...

Group it all together and do it by group but you can also just do it by groups and facet wrap by metaphor measure for 
indiv question results. 
```{r}
plot_group_density <- function(d0, d1, d2) {
  p <- ggplot(rbind(d0, d1, d2), aes(x=score, fill=vid)) + 
      geom_density(alpha=0.3, stat="density", adjust=0.8) +
      facet_wrap(~group, scale="free")
  return(p)  
}

plot_question_density <- function(d0, d1, d2) {
  p <- ggplot(rbind(d0, d1, d2), aes(x=score, fill=vid)) + 
      geom_density(alpha=0.3, stat="density", adjust=0.8) +
      facet_wrap(~metaphor_measure, scale="free")
  return(p)  
}
```


#### Put it together and how do you do? Bibbity Bobbity BAM.
```{r}
## random helpers
gather_select <- function(d) {
  d <- d %>%
    gather("metaphor_measure", "score", 1:12) %>%
    select("metaphor_measure", "score")
}

wrangle_data <- function(d, name="data") {
  gathered <- gather_select(d)
  grouped <- add_groups(gathered)
  overlay_plot <- create_grouped_overlay(grouped)
  diff_mat <- create_difference_matrix(d)
  diff_mat$vid <- name
  list_of_returns <- list("gathered" = gathered, "grouped" = grouped, "overlay_plot" = overlay_plot, "diff_mat" = diff_mat)
  return(list_of_returns)
}


do_the_thing <- function(d0, d1, d2, n0 = "original", n1 = "a_condition1", n2 = "z_condition2", gesture = "single") {
  d0_data <- wrangle_data(d0, n0)
  d1_data <- wrangle_data(d1, n1)
  d2_data <- wrangle_data(d2, n2)
  
  graph_title <- paste("Correlation of questions for", gesture, "gesture across conditions.")
  
  # wrangle data
  overlays <- list("d0_overlay" = d0_data$overlay_plot, "d1_overlay" = d1_data$overlay_plot, "d2_overlay" = d2_data$overlay_plot)
  difference_matrix <- plot_diff_matrix_pretty(rbind(d0_data$diff_mat, d1_data$diff_mat, d2_data$diff_mat), 
    "Correlation of questions across single gesture for three conditions") + 
    facet_wrap("vid")  
  
  ## rename some things for the density plots
  db_named <- d0_data$gathered
  da_named <- d1_data$gathered
  dc_named <- d2_data$gathered
  db_named$vid = "original"
  da_named$vid = "a_condition1"
  dc_named$vid = "z_condition2"
  d0_grouped_named <- add_groups(da_named)
  d1_grouped_named <- add_groups(db_named)
  d2_grouped_named <- add_groups(dc_named)
  
  ## violin density plot 
 violin_density_question <- plot_violin_density(da_named, db_named, dc_named) 
 violin_density_grouped <- plot_violin_density_grouped(d0_grouped_named, d1_grouped_named, d2_grouped_named)
 
 ## plot density plot -- with groups
 density_grouped <- plot_group_density(d0_grouped_named, d1_grouped_named, d2_grouped_named)
 density_question <- plot_question_density(d0_grouped_named, d1_grouped_named, d2_grouped_named)
 
 return_list <- list("overlays" = overlays, "correlation_matrix" = difference_matrix, 
                     "violin_density_question" = violin_density_question, "violin_density_grouped" = violin_density_grouped,
                     "density_grouped" = density_grouped, "density_question" = density_question)
}

all_unpolite_data <- do_the_thing(u0, u1, u2, "original", "intertwine", "collide")
all_entity_data <- do_the_thing(e0, e1, e2)
all_audience_data <- do_the_thing(a0, a1, a2)

all_correlational_data <- plot_diff_matrix_pretty(rbind(create_difference_matrix(u0), create_difference_matrix(u1), create_difference_matrix(u2),
                                                        create_difference_matrix(e0), create_difference_matrix(e1), create_difference_matrix(e2),
                                                        create_difference_matrix(a0), create_difference_matrix(a1), create_difference_matrix(a2)), 
    "Correlation of questions across single gesture for three conditions") 
```
Cool now access everything as follows:
all_dat$overlays[["d0_overlay"]]: the overlayed violin plot of related questions. Illustrates density overlay aka a nice vis of correlation of questions
all_dat$correlation_matrix: the correlation matrices that visualize the above as well.
all_dat$violin_density_question: the violin plot of all question distributions across gesture conditions.
all_dat$violin_density_grouped: the violin plot of group distributions across gesture conditions.
all_dat$density_grouped: density plot of group distributions across gesture conditions.
all_dat$density_question: density plot of all question distributions across gesture conditions.




## Stats
Pretty, but what does it mean? Well, to determine whether any of these differences are significant (aka, did people interpret different things from each of the different gesture conditions, which, because we, too, are people, we know they did) we need to see what the significant differences between rankings in each gesture and condition are.
```{r}
## gather the bad larries
gather_clean <- function(d, n="") {
  ret <- d %>%
    gather("metaphor_measure", "score", 1:12) %>%
    mutate(condition=n) %>%
    add_groups()
  return(ret)
}

do_anova_per_group <- function(data, g) {
  group_data <- data %>%
    filter(group==g)
  res.aov <- aov(score ~ condition, data=group_data)
  print(g)
  print(summary(res.aov))
  return(res.aov)
}

do_anova_per_data <- function(data) {
  groups <- c("open",
              "conflict",
              "control", 
              "size",
              "sure",
              "unity")
  
  print("==== BY GROUP ====")
  for (g in groups) {
    print(g)
    a <- do_anova_per_group(data, g)
    print(summary(a))
    print("========================")
  }
}

do_anova_per_gest <- function(d0, d1, d2) {
  d <- rbind(gather_clean(d0, "original"), 
             gather_clean(d1, "cond1"), 
             gather_clean(d2, "cond2"))
  do_anova_per_data(d)
}

do_all_anovas <- function() {
  print("!!!!UNPOLITE!!!!!")
  do_anova_per_gest(u0, u1, u2)
  print(" ")
  print("!!!!ENTITY!!!!!")
  do_anova_per_gest(e0, e1, e2)
  print(" ")
  print("!!!!AUDIENCE!!!!!")
  do_anova_per_gest(a0, a1, a2)
}

do_all_anovas()
```


Now get those T-Tests done DID.

```{r}

get_sig_val <- function(p) {
  if(p < 0.0005) {
    return("***")
  }
  if(p < 0.005) {
    return("**")
    }
  if(p < 0.05) {
    return("*")
  }
  return ("")
}

do_t_test_adjusted <- function(cond1, cond2, statement, dat) {
  print(dat)
  d <- data.frame()
  if(dat == "1") {
    d <- unp_d
  }
  if(dat == "2") {
    d <- e_d
  }
  if(dat == "3") {
    d <- a_d
  }
  
  p <- as.numeric(t.test(
            get_vals(cond1, statement, d),
            get_vals(cond2, statement, d))[3])
  p_adjusted <- round(p.adjust(p, method="bonferroni", n=6), digits=5)
  return(p_adjusted)
}

get_vals <- function(condition_name, g, dat) {
  ret <- dat %>%
    filter(condition==condition_name) %>%
    filter(group==g)
  ret <- ret$score  
  return(ret)
}


# For some reason can't generalize this to all gestures?
make_table_per_gesture <- function(gest_name, cond1name, cond2name, dat) {
  groups <- c("open",
            "conflict",
            "control", 
            "size",
            "sure",
            "unity")

  group <- rep(groups, each=3)
  cond1 <- rep(c(cond1name, cond2name, "original"), 6)
  cond2 <- rep(c("original", cond1name, cond2name), 6)
  df <- data.frame(group, cond1, cond2)   
  
  df$p <- mapply(do_t_test_adjusted, 
               as.character(df$cond1), 
               as.character(df$cond2), 
               as.character(df$group),
               dat)
  df$sig <- mapply(sig, df$p)

  return(df)
}

u0_g_cl <- gather_clean(u0, "original") 
u1_g_cl <- gather_clean(u1, "cond1") 
u2_g_cl <- gather_clean(u2, "cond2")
unp_d <- rbind(u0_g_cl, u1_g_cl, u2_g_cl)

e0_g_cl <- gather_clean(e0, "original") 
e1_g_cl <- gather_clean(e1, "cond1") 
e2_g_cl <- gather_clean(e2, "cond2")
e_d <- rbind(e0_g_cl, e1_g_cl, e2_g_cl)

a0_g_cl <- gather_clean(a0, "original") 
a1_g_cl <- gather_clean(a1, "cond1") 
a2_g_cl <- gather_clean(a2, "cond2")
a_d <- rbind(a0_g_cl, a1_g_cl, a2_g_cl)

gest_1_sig_table <- make_table_per_gesture("unpolite", "cond1", "cond2", "1")
gest_2_sig_table <- make_table_per_gesture("entity", "cond1", "cond2", "2")
gest_3_sig_table <- make_table_per_gesture("audience", "cond1", "cond2", "3")
```
